# Gemini Code Generation Principles

This document outlines the core principles that guide code generation within this project, especially when leveraging AI models like Gemini. Adhering to these principles ensures that generated code is high-quality, maintainable, and seamlessly integrates with existing project standards.
Apply S.O.L.I.D. Principles. Make sure the Single Responsability Principle is applied.

## 1. Clarity and Readability

*   **Self-Documenting Code:** Prioritize clear variable names, function names, and logical structures. Avoid unnecessary complexity.
*   **Conciseness:** Generate code that is as short as possible without sacrificing clarity.
*   **Consistent Formatting:** Adhere strictly to the project's established code style (indentation, spacing, line breaks, etc.).

## 2. Correctness and Functionality

*   **Functional Accuracy:** Generated code must correctly implement the specified requirements and produce the expected output.
*   **Error-Free:** Code should be free of syntax errors, logical bugs, and common pitfalls.
*   **Edge Case Handling:** Consider and appropriately handle common edge cases and invalid inputs.

## 3. Maintainability and Extensibility

*   **Modularity:** Generate code in small, focused units (functions, components, modules) with clear responsibilities.
*   **Loose Coupling:** Minimize dependencies between different parts of the generated code and existing codebase.
*   **Extensibility:** Design code to be easily extended with new features without requiring significant modifications to existing logic.
*   **Avoid Magic Numbers/Strings:** Use named constants or configuration where appropriate.

## 4. Performance and Efficiency

*   **Resource Awareness:** Generate code that is mindful of computational resources (CPU, memory) and avoids unnecessary operations.
*   **Optimized Algorithms:** Where performance is critical, prefer efficient algorithms and data structures.

## 5. Security

*   **Vulnerability Avoidance:** Generate code that is free from common security vulnerabilities (e.g., injection flaws, insecure deserialization, cross-site scripting).
*   **Input Validation:** Ensure all external inputs are properly validated and sanitized.

## 6. Adherence to Project Conventions

*   **Style Guide Compliance:** Follow any existing project-specific style guides or linting rules.
*   **Architectural Patterns:** Conform to established architectural patterns and design decisions within the project (e.g., React hooks, Redux patterns, specific component structures).
*   **Naming Conventions:** Use consistent naming for files, variables, functions, and components.

## 7. Testability

*   **Unit Test Friendly:** Generate code that is easy to unit test, with clear inputs and outputs.
*   **Mockable Dependencies:** Design components and functions to allow for easy mocking of dependencies during testing.

## 8. Documentation (When Necessary)

*   **High-Value Comments:** Add comments sparingly, focusing on *why* complex logic is implemented, rather than *what* it does.
*   **API Documentation:** For public interfaces (e.g., exported functions, component props), generate clear and concise documentation.

---

By following these principles, we aim to ensure that any code generated by Gemini or similar tools enhances our project's quality and accelerates development effectively.
